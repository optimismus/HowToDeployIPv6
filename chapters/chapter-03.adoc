image::images/image03_01_citrus.jpeg[Citrus fruits from small to big,width=913,height=609]

<<<

[big]#*Block sequencing*#

IPv6 deployment is logically to be done starting with the bottom, the network layer. 
And before any deployment it is coherent to prototype the behavior of each component. 
Very few organizations have an end-to-end lab and qualification environment, both horizontally within the same layer and vertically between layers. 
For example, your campus, datacenter and security network prototypes may be managed by different teams and are not interconnected in a topology close to the production one, this is a horizontal break. 
If a qualification server is running on a network with production routers, we have a vertical break. 
This makes sense, otherwise how can you debug a problem if all the stack layers are in test, it would look like a multi-level rola-bola.

We will retain that each layer has its own test environments, and that those run on lower layers' production environments. 
In short, every qualification runs itself on an underlying production environment (except for the foundation that is network). 
This can be represented as follows:

image::images/image03_02_blocks.svg[IPv6 workflow,width=566,height=185,title="Sequences"]

== Warm up

Before you even decide where to begin, start by making sure that all of your current and future specifications / RFPs / subcontractors requests include IPv6 compatibility and guarantee its proper functioning. These processes often take a long time to change, so it is advisable to start working on them right away.

This also includes build, run, life cycle processes and everything related to them.

== Network

Network is the first pillar to deal with, let's start with some questions to consider about the devices:

* Does an appliance work in IPv6? (Ask the equipment manufacturer, integrator, test, etc.);
* Is there a gap in functionality / regressions with IPv6 compared to IPv4? (e.g.: does a probe have the same detection capabilities, the same rule and signature running policies);
* Is there a performance gap with IPv4 (e.g.: is the number of packets filtered per second on a firewall of the same order of magnitude? are the ASIC hardware features equivalent? such as IPSEC or TCP offloading on the OS VM/Hypervisor/Driver NIC chain or TLS on a load balancer);
* Is the device administration possible via IPv6? Its control, its supervision, etc. or does it only do IPv6 in transit data plane and not on admin side.

Implementation difficulty increases as the device's ability to climb the layers of the OSI model increases, because more and more functions must be tested, and the risk of omission/configuration heterogeneity also increases.

It is therefore easy to deal with routers, once the routing protocols have been mastered, while avoiding immediately providing dual stack to end-user networks to allow time for validating security mechanisms specific to v6 in host networks.

Then the infrastructure networks without reaching the user.

Then we move on to the filtering and flow optimization devices, where the object-based model allows most policies/ACL to be dual-stacked by acting only on the objects to reflect the v6 subnets/address in correlation with v4.

User access can only be active after the security component is rolled out to both network devices and hosts.

The rest requires more work, and concerns the advanced network services present in datacenter like load balancers, waf, probes, etc.

=== • Readiness

The IPv6 compatibility maturity varies according to device types. 
In a general manner, carrier-grade routing appliances have been free of problems for years. 
On the contrary, campus devices still sometimes encounter a few bugs, especially regarding security features.

.The IPv6 evolution
image::images/image03_03_ipv6-evolution.svg[IPv6 evolution,width=561,height=287]

Solution maturity appears to follow the graph above, pay attention to SD-WAN and Campus SDN solutions, refer to the SD-WAN paragraph in the Transport Mechanisms section whose elements also apply to Campus SDN.

Tracking release notes and known bugs allows you to see when IPv6 support is maturing, focusing on v6 specific bugs. 
The evolution generally follows the probability density of a normal distribution and thus a Gaussian curve.

=== • HARDWARE

Consider checking your routers' ternary memory allocation, some configurations have little room for IPv6 routes to be stored. 
Some ASICs on the market store IPv6 /48 routes (and sometimes other frequent sizes) differently than other prefix sizes.

IPv6 full view is growing exponentially, so take some leeway when choosing devices handling public peering. 
If you are short on space but still need BGP full view, you can dedicate some routers to v6 peerings and others to v4, if the technical and economic study is satisfactory.

As addresses are longer, they take 4x more space in memory. 
Think about routing tables, ACL, stateful tables, logs. 
Hopefully they often consume only 2x more space as IPv4 as long as /64 are considered. 
That’s often the case for routing tables and routing decisions.

//image:extracted-media/media/image16.svg[Connexions contour,width=75,height=75] Marginalspalte ??
=== • LAB

Trying out features, from the simplest ones like routing to the most advanced ones like security mechanisms, can be done on a variety of environments. 
In stand-alone or not. 
Some tests, such as QoS validation, require a physical chassis and a traffic generator, whereas an ospfv3 test can, in all likelihood, be conducted on a virtual instance. 
The dependency on ASICs being limited.

One can imagine distributing the tests as follows, knowing that the tests can be shifted from the left columns to the right ones. 
However, this makes their execution more complex, to the point of increasing the risk, the last column being in production tests.

[width="100%",cols="15%,32%,32%,21%",options="header",]
|===
a|
Environnement min.

Device

|Virtual Lab (vendor environment or eveNG like,…) |Independent physical lab |Pilot phase on production
|L2 Switch a|
- Configuration validation without real test

- Some virtual L2 tests may not be very accurate depending on the vendor.

a|
- Access security (eg: RA guard)

- MLD snooping

- 802.1x

- QoS

- ACL

- Stack behavior

|- In production host behavior
|Wifi AP |N/A a|
- Previous elements (except stack…)

- Controller reachability

- Local routing outside tunnel

- ACL

|- In production host behavior
|Router a|
- Protocols (OSPFv3, IS-IS, MP-BGP)

- FHRP (HSRP, VRRP)

- Multicast (PIM, MLD,…)

- DHCP relay

- ACL, route-map

- Router / FW neighborship

- DCI

- PMTU Discovery

a|
- Previous elements

- Access security (RA guard, etc.)

- QoS

- BFD

- ARP/ND inspect

- Dual-Stack provisioning to access networks

- Performance

a|
- In production host behavior

-Scaling

|FW _(additionally to router features)_ a|
- Previous elements

- Editing objects/rules in v6

- NAT64

- v6 transit filter rules

- L7 non-regression tests

a|
- Previous elements

- FW HA

- transit v6 filtering rules

- Vendor controller

- IPsec

- v6 logs + NAT64 logs

a|
- ACL orchestration integration

- Integration of v6 logs + NAT64 logs

- In production host behavior

|Load Balancer (SLB) a|
- Object/rule editing in v6

- L7 non-regression tests

- NAT64

a|
- TLS offloading

- Performance

- v6 logs

|
|IPS/IDS |- Object/rule editing in v6 |- Previous elements |- Prod SIEM processing
|Wan Optimization a|
- Object/rule editing in v6

- L7 non-regression tests

|- Previous elements |
|Proxy a|
- Object/rule and PAC editing in v6

- Guest behavior

|- Previous elements |
a|
DNS

IPAM

DHCP

a|
- DNS64

- AAAA records

- Reverse PTR

- IPAM v6 blocks

- DHCPv6 with options

a|
- Previous elements

- Host self-registration

- Service provided in IPv6

|
|===

In an effort to help you, RIPE has published https://www.ripe.net/publications/docs/ripe-772[RIPE-772] which is a list of compatibility points to check and ask for when issuing an RFP.

The US NIST published in 2020 the revision of its https://www.nist.gov/programs-projects/usgv6-program/usgv6-revision-1[USGv6-rev1] test program.

=== • INTERNAL ROUTING

Depending on your network layout, the introduction of IPv6 will require deep changes in terms of routing protocols configuration.

//[#_Toc88922652 .anchor]####BGP
==== BGP

Even if the address family v6 implementation in MP-BGP simplifies the work in BGP, it will be necessary to analyze the route classification rules of type access/prefix lists/sets so that the IPv6 addresses are taken into account to apply the route map/policy correctly and in a coherent way to IPv4. 
In order to limit inconsistencies, base your rules on communities when possible and mark these communities on the capillary networks rather than having to maintain lists of v4 and v6 prefixes everywhere. 
The rigor of a v4/v6 mapping table and automation is another valid strategy, either distributed on routers or centralized on a route server such as FreeRangeRouting, Bird, Quagga (probably facilitating other aspects of your routing engineering if you are the type of person who often tweaks BGP).

//[#_Toc88922653 .anchor]####IGP
==== IGP

2 solutions are to be considered regarding IGP. 
Either use IS-IS from ISO which is IP agnostic, more flexible than OSPFv3 but rarely deployed in companies. 
It is the IGP that dominates today on large carrier networks, notably because of its convergence and its partial recalculation mechanism.

Moreover, the arrival of IPv6 SRv6-based Segment Routing requires IS-IS and its TLVs, even if OSPF LSAs have been created to offer an equivalence, the market and manufacturers seem to be primarily turning towards IS-IS (check with your vendors).

The other solution is to switch to OSPFv3 and, once it is stabilized, to include AddressFamilyIPv4 in order to remove OSPFv2, perimeter after perimeter if the devices are compatible with the provision of IPv4 routes in OSPFv3 RFC 5838.

Keeping the 2 versions of OSPF in parallel brings the classical problems of dual-stack (configuration homogeneity between v4 and v6, configuration overhead, monitoring equivalence, etc.).

For a large organization, IS-IS training is probably worth the cost, especially to prepare you for SRv6.

Don't forget that only the IGPs that carry client networks are concerned, generally the capillary ones. 
It is useless to modify the underlay IGP of your MPLS or your VxLAN EVPN since BGP takes care of v6 in the overlay layer.

.6VPE Topology
image::images/image03_04_6vpe-topology.svg[6VPE Topology,width=564,height=279]

=== • FILTERING AND TRACKING

Before transmitting flows, it will be necessary to reach the same level of security than in IPv4. 
The security section contains many elements on the topic. 
You will also find in the chapter " v4/ v6 mapping " of the addressing section some advices to facilitate the rules transcription.

== Infrastructure services

Many critical services go hand in hand with the proper operation of the infrastructure. 
Some enable connectivity, others target security aspects, etc.

Regardless of which IPv6 deployment scenario you choose for your organization, the implementation schedule within the infrastructure services will be similar.

//image:extracted-media/media/image26.svg[Empreintes contour,width=75,height=75] Marginalspalte ??
=== • SIEM

Each time a new service is migrated, logs must be collected and correlated as efficiently as with IPv4. 
Adapting your SIEM is therefore essential throughout the project, so in the long term, plan to have resources on the subject. 
The transcription of log parsing rules is rather time consuming. 
It would be a good idea for the main editors to offer turnkey conversion mechanisms.

Make sure that the log sources send the address between brackets followed by the port [IP]:port. 
Without brackets it is difficult to separate both, you can bet on the fact that the last group of numbers is the port, but some applications sometimes don't send it when the source port is the same as the server socket and a simplification function is called when it shouldn't be (rare case but not impossible).

Be careful with the storage of IPv6 addresses, see the applications section a few pages further.

=== • DNS/IPAM/DHCP

This set of services is often entrusted to the same application solution, except for specific DNS zones such as those assigned to a Microsoft Active Directory environment.

In any case, the production interfaces of such services accessible by clients are a priority to be switched to dual-stack.

The services that interact with the administration interface of the devices do not need to be provided immediately in IPv6. 
This is for example the case for NTP, RADIUS, TACACS, SYSLOG servers... which can wait. 
It is different if your scenario targets a v6 deployment on the administration networks.

=== • VPN, PROXY AND REVERSE PROXY

These services have the particularity of having both internal and external pointing interfaces. 
IPv6 provisioning can be implemented regardless of the 2 sides, since the use cases are different.

//[#_Toc88922659 .anchor]####External
==== External

Probably the one to implement even if you are not aiming at an internal use of IPv6 at all, the possibility to communicate over the internet will allow your users and customers to reach you with a native IPv6 connectivity at a time when IPv4 sharing tinkering is becoming widespread. 
Conversely, it will allow proxy browsing to reach IPv6 sites without problems.

Thus, your VPN gateway and your reverse proxy should be exposed in dual-stack as soon as possible, avoiding you to have your flows crossing Carrier-Grade NAT and other joyful things without any possible control on your side. 
We remind you that the reverse proxy can also offer public IPv6 connectivity to IPv4 servers. 
This is another way to regain control over this translation on the Internet side.

//[#_Toc88922660 .anchor]####Internal
==== Internal

The internal aspect goes alongside the deployment of IPv6 on its LAN. 
It will be necessary to focus on the correct definition of its PAC proxy files, as well as to ensure that the VPN rules are transposed, particularly those related to split tunneling.

//image:extracted-media/media/image18.svg[Ordinateur portable contour,width=75,height=75] Marginalspalte ??
=== • OS image

While OS TCP/IP stacks have been supporting IPv6 for a decade, support for some RFCs such as providing IP DNS via router advertisement (RDDNS) are more recent. 
For example, support on Windows 10 starts with build 1703.

//[#_Toc88922662 .anchor]####Precedence
==== Precedence

The precedence concept defines the priority given to the different types of addresses, and thus notably the prioritization of v6 over v4 or the opposite.

The order is standardized, RFC 6724 dated 2012 replaces 3484 from 2003. 
Here are the differences:

[width="100%",cols="22%,19%,27%,32%",options="header",]
|===
|Address        |Prefix         a|Former Precedence +
(RFC 3484)
                                        a|New Precedence +
(RFC 6724)

|IPv6 Loopback  |::1/128        |50     |50
|Natives IPv6   |::/0           |40     |40
|IPv4           |::ffff:0:0/96  |10    a|_35_
|6to4           |2002::/16      |30     |30
|Teredo         |2001::/32      |05     |05
|ULAs           |fc00::/7       |40    a|*03*
|site-local     |fec0::/10      |40    a|*01*
|6bone          |3ffe::/16      |40    a|*01*
|IPv4compat     |::/96          |20    a|*01*
|===


It can be noted that between the 2 releases, IPv4 has become preferred over v6 transition mechanisms (6to4, Teredo) and that local site addresses are now deprecated. 
Native IPv6 still has the lead.

Beware also of private ULA addresses which are getting lower priority than IPv4, this can matter.

.Precedence in Windows 10
image::images/image03_05_precedencetable.png[Windows netsh,width=383,height=195]

Result of `netsh interface ipv6 show prefixpolicies` command. 
This behavior can be changed using the following registry key HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\tcpip6\Parameters documented http://support.microsoft.com/kb/929852[here]

.Man page Debian 10 (Buster) of GAI.CONF
image::images/image03_06_linux.png[man page,width=546,height=244]

//==== image:extracted-media/media/image40.svg[extracted-media/media/image40,width=68,height=49] 
On many GNU/Linux distributions it can be controller in the GetAddressInfo file _/etc/gai.conf_ .

Here an example of Debian 10 (Buster) man page, no clue of the new RFC from 2012… https://man7.org/linux/man-pages/man5/gai.conf.5.html

Changing IPv4 precedence (represented by ::ffff:0:0/96) can help you to prevent any malfunction on a production system when deploying IPv6. 
Indeed, unless a literal specification of an IPv6 address or a DNS record that matches only an IPv6 address is specified, the system will continue to use IPv4 for the requests it submits. 
Remember to normalize once a stable state is reached.

Be aware that some programs such as browsers implement their own prioritization between v6 and v4, independently of the OS stack configuration. 
Also, the implementation of the Happy Eyeballs 2 mechanism (RFC 8305) may vary. 
(Delay between DNS A and AAAA requests, time to wait for the return, timeout of the remote socket with failover...). 
Another example, the CURL tool nicely supports Happy Eyeballs compared to its competitors.

//[#_Toc88922663 .anchor]####Software agents
==== Software agents

OS images are usually internally shipped with preconfigured agents, more rarely these agents are deployed at first launch. 
In both cases, they are a part of the base and allow to ensure its compliance, security, etc.

These agents include backup, antivirus, telemetry and monitoring, asset management, package/strategy deployment, etc.

As long as you do not plan to retire IPv4, there is no need to prioritize the transition of these services to dual-stack, it can be done at the same time as the applications.

The important point is to check that these agents do not encounter any problem linked to the simple presence of a routable IPv6 address on the host.

So don't picture an Ouroboros where you must do everything at the same time without knowing where to start.

Once the OS bases are ready for dual-stack operation, you can work on moving to IPv6 only once the ecosystem is ready, if that is your scenario, and then you can tackle the upper layers, the middleware and applications.

//=== image:extracted-media/media/image18.svg[Ordinateur portable contour,width=75,height=75] Marginalspalte ??
=== • WORKPLACE SERVICES

//[#_Toc108476643 .anchor]####Directory
==== Directory

Directory Service carries LDAP and Kerberos functionalities, in addition to occasionally hosting specific DNS zones and other ancillary services. 
Their omnipresence within the information system makes their migration essential. 
The leading product on the market, Active Directory, works well in dual-stack, it has been in fact used internally by its editor in IPv6 for several years.

//image:extracted-media/media/image58.png[extracted-media/media/image58,width=50,height=32]
[NOTE] 
====
*regarding SPN (Kerberos Service Principal Name)*

In an effort to simplify the declaration of each server and its service behind a single name, some implementations by default rely on a reverse DNS query. 
Thus, when the user requests a service ticket for a server via a CNAME rather than its original hostname, the Kerberos server will retrieve the original FQDN via reverse DNS. 
The other tedious solution is to declare all possible SPNs of each server.

This behavior (canonical resolution), although discouraged by RFC 4120, is used within Active Directory for its simplicity. It is therefore necessary to make sure that the Kerberos server (KDC) will not execute a reverse DNS query with an IP retrieved through a DNS64, or at least that the DNS server knows how to lie and formulate an appropriate response to these particular queries.

Last but not least, there are still some IP-based SPNs rather than hostname-based SPNs (usually for old applications with, you have guessed, a hard-coded configuration, or simply an IP-based configuration). 
This is a rare case since Windows on the client side stopped to support this function between Vista and Win 10 1507, forcing to downgrade to NTLM for such services. 
This specific case will require the use of 2 SPN per machine and service (v4 and v6).
====

//[#_Toc108476644 .anchor]####File shares and package repositories
==== File shares and package repositories

Whether they are visible to users or not, servers providing files generate a heavy traffic load. 
If your project targets v6-only clients with NAT64 it would be a good idea to have these servers migrated to a dual-stack (or have dedicated translation platform) which would greatly relieve the centralized translation platform.

This includes SMB, NFS, WSUS, SCCM, package repositories, EDR signature repositories, CMS, Sharepoint, etc.

IMPORTANT: *NFS older version 4 uses Portmapper and doesn't works with NAT64.*

//[#_Toc88922666 .anchor]####Communication
==== Communication

The e-mail infrastructure can cope with NAT64 for a long time, but the large amount of traffic this system generates makes it necessary to migrate at least the client access layer to IPv6. 
For the internet facing portion, the MTA, there is no rush, we are not about to see SMTP servers offering exclusively IPv6. 
A migration will require checking the compatibility and efficiency of your content checking and antispam solutions.

//image:extracted-media/media/image20.svg[Combiné contour,width=75,height=75] Marginalspalte ??
Similarly, in telephony, it is the customer-facing part of the system that needs to be quickly migrated, and much more urgently than messaging, in order to bring IPv6 compatibility to P2P communications between customers or between customers and centralized infrastructure. 
Urgency reinforced by the bad surprises of NAT64 with SIP, unless you trust ALGs. 
But RTP flows being more and more frequently encrypted, you should not rely too much on ALGs.

You should know that a growing number of SaaS providers support IPv6, with some rare exceptions such as an on-premise SBC interfacing with its SaaS counterpart, which is not very annoying.

//image:extracted-media/media/image32.svg[Conception web contour,width=75,height=75] Marginalspalte ??
=== • APPLICATIONS

Rather than specifically launching a tedious qualification campaign devoted to IPv6, it is preferable to use the opportunities offered by major upgrades of these applications to qualify them, this time in IPv6, and only in IPv6. 
Feedback from major editors shows that qualifying an application in IPv6 is enough and that it is useless to re-cycle everything in IPv4, as recent methods and instruction calls are backwards compatible without additional work. 
This is obviously not true for an application using an old programming language and/or with hard-coded addresses.

Here is a list of questions to ask yourself about each application:

* *Are there any users of the solution in v6?* (ask the editor, integrator, test...);
* *Is the programming language used compatible with IPv6?* And in a stable and reliable way? (Many implementation bugs have been corrected in different languages up to 2015);
* *Is the socket opening code agnostic of the IP protocol version?* Inet6Address and InetAddress in Java for example;
* *Does IPv4 and v6 traffic pass through the same socket?* Previous example vs use of IPv4-mapped address (still in Java);
* *Does an application handle IPv6 on the client side?* on the server front-end? on the server back-end in the case of an n-tier application? (even if this last point is less critical);
* *Does an application make calls via literal address rather than via DNS lookup?* IPv4 configuration field only for example;
//image:extracted-media/media/image26.svg[Empreintes contour,width=75,height=75] Marginalspalte ??
* *Does an application use a protocol embedding the literal address?* Like SIP with telephony, or active FTP;
* *Does an application initiate connections to client endpoints?* Example of active FTP with its 2 concurrent control and data sessions, one in each direction. Or remote control, as well as SIP, DICOM, etc.;
* *Is there any IP address processing within your application?* For example, identifying the client by its IP rather than by its username;
* *Is RFC 8305 "Happy Eyeballs v2" correctly implemented to allow fast switching between the 2 protocols?* (The calling function used and the default language configuration should be looked at in detail, it is very easy to not implement it correctly in java for example);
* Finally, if the application is not IPv6 compatible, *will the logs retain the port in addition to the IP?* (To ensure NAT64 tracking) cf RFC 7768 of 2016, itself inspired by RFC 6302 of 2011 which initially recommended this for front-end servers on the Internet.

Various audit tools exist, some are integrated into development environments, others standalone such as Microsoft checkv4, PortToIPv6, IPv6 code checker, IPv6 care, etc. 
These tools can either audit the code or detect socket calls when the code is running and identify the used method.

Mobile applications published on the Google Play Store and the Apple App Store are bound to use IPv6 compliant network methods and functions since 2016, it has been a good example of fast code adaptation.

Without delay, incorporate IPv6 into your specifications and architecture requirements for new applications. 
Also schedule a date when upgrades of an existing application should include IPv6 implementation.

image::images/image03_07_webapp.png[Web App,title="Example of analysis of a Web App"]

==== How to deal with a service provided through web browsers?

In n-tier architectures, priority is given to the front end, which is accessed by clients. 
The application back-end can remain in v4 much longer.

Ideally, you should take advantage of application obsolescence and renewal to implement IPv6.

Just to know, the famous Curl utility have now been supporting IPv6 for more than 20 years.

//[#_Toc108476647 .anchor]####Case of apps handling IP
==== Case of apps handling IP

IP address is a key element found in inventories; it may include the following tools:

* Assets management / CMDB / IPAM;
* Infrastructure config Orchestrator / Deployment / Config Backup;
* Operation monitoring / metrology / incidents tracking / helpdesk;
* Information harvesting scripts;
* Log correlation (SIEM) / Audit;
* Access management Flow openings / Identity.

Usage of IPv6 implies reviewing address storage and processing for various reasons:

* IPv6 address sometimes comes in addition to IPv4 (dual-stack);
* It is longer;
* An interface can carry several IPv6 (local link, temporary routable, stable routable, etc.).

A simplification method can be to manipulate everything like IPv6, including IPv4 through the representation prefix ::ffff:0:0/96. 
This way eases application code cohesion and simplification.

However, see the Appendix in the section Examples of implementation problems to find a possible problem with this method.

In any case, it will be necessary to store the addresses in their canonical (shortened) shape in order to reduce their size. 
The code performing the canonicalization must scrupulously respect the RFC 5952 so you always end up with the exact same string to parse. 
Note that addresses must also be stored with lowercase characters (RFC section 4.3). 
For example, ab01::ffff and not AB01::FFFF. 
The non-fulfilment of this last recommendation can even cause problems in protocols carrying the IP in payload like SIP.

//#### End of chapter ####